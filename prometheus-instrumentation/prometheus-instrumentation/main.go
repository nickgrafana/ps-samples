package main

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/carlmjohnson/requests"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	log "github.com/sirupsen/logrus"
	"math"
	"math/rand"
	"net/http"
	"os"
	"strconv"
	"time"
)

var MaxSleep, _ = strconv.ParseFloat(GetEnv("MAX_SLEEP", "0.35"), 64)
var MaxError, _ = strconv.ParseFloat(GetEnv("MAX_ERR", "0.065"), 64)

func init() {

	log.SetOutput(os.Stderr)
	log.SetReportCaller(true)

}

type AutoGenerated struct {
	Time     string  `json:"time"`
	Duration float64 `json:"duration"`
}

func GetEnv(key string, def string) string {
	val, ok := os.LookupEnv(key)
	if !ok {
		return def
	} else {
		return val
	}
}
func randFloat(min, max float64) float64 {
	return math.Round((min+rand.Float64()*(max-min))*1000) / 1000
}

var (
	summary = prometheus.NewSummaryVec(prometheus.SummaryOpts{
		Name: "request_summary_seconds",
		Help: "Time taken to complete a request.",
		Objectives: map[float64]float64{
			0.5:  0.05,
			0.9:  0.01,
			0.99: 0.001,
		},
	},
		[]string{"path"},
	)
	summaryLocal = prometheus.NewSummaryVec(prometheus.SummaryOpts{
		Name: "request_local_summary_seconds",
		Help: "Time taken to complete a request.",
		Objectives: map[float64]float64{
			0.5:  0.05,
			0.9:  0.01,
			0.99: 0.001,
		},
	},
		[]string{"path"},
	)
	summaryMemory = prometheus.NewSummaryVec(prometheus.SummaryOpts{
		Name: "memory_summary_bytes",
		Help: "Memory usage of requests.",
		Objectives: map[float64]float64{
			0.5:  0.05,
			0.9:  0.01,
			0.99: 0.001,
		},
	},
		[]string{"path"},
	)
	gauge = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "memory_total_bytes",
			Help: "Total memory usage in bytes.",
		},
		[]string{"path"},
	)
	counter = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "paths_total_count",
			Help: "Path requested counter.",
		},
		[]string{"path"},
	)
	histogram = prometheus.NewHistogramVec(prometheus.HistogramOpts{
		Name:    "request_seconds",
		Help:    "Time taken to complete a request.",
		Buckets: []float64{0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1},
	},
		[]string{"path"},
	)
	histogramLocal = prometheus.NewHistogramVec(prometheus.HistogramOpts{
		Name:    "request_local_seconds",
		Help:    "Time taken to complete a request.",
		Buckets: []float64{0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1},
	},
		[]string{"path"},
	)
	histogramMemory = prometheus.NewHistogramVec(prometheus.HistogramOpts{
		Name:    "memory_bytes",
		Help:    "Memory usage of requests.",
		Buckets: prometheus.LinearBuckets(0, 250000, 5),
	},
		[]string{"path"},
	)
)

func measure(service string, local, total float64) {

	total = math.Round(total*100) / 100
	memory := math.Round((1000000 * local) / MaxSleep)

	if MaxError >= rand.Float64() {
		fmt.Println(fmt.Sprintf("%s - ERROR %s: local: %f, total: %f, memory: %f", time.Now().Format(time.RFC3339), service, local, total, memory))
		log.SetFormatter(&log.JSONFormatter{})
		log.WithFields(log.Fields{
			"local":  local,
			"total":  total,
			"memory": memory,
		}).Error(service)

		log.SetFormatter(&log.TextFormatter{
			DisableColors: true,
			FullTimestamp: true,
		})
		log.WithFields(log.Fields{
			"local":  local,
			"total":  total,
			"memory": memory,
		}).Error(service)
	} else {
		fmt.Println(fmt.Sprintf("%s - OK %s: local: %f, total: %f, memory: %f", time.Now().Format(time.RFC3339), service, local, total, memory))
		log.SetFormatter(&log.JSONFormatter{})
		log.WithFields(log.Fields{
			"local":  local,
			"total":  total,
			"memory": memory,
		}).Info(service)
		log.SetFormatter(&log.TextFormatter{
			DisableColors: true,
			FullTimestamp: true,
		})
		log.WithFields(log.Fields{
			"local":  local,
			"total":  total,
			"memory": memory,
		}).Info(service)
	}

	counter.With(prometheus.Labels{"path": service}).Inc()     //request number
	gauge.With(prometheus.Labels{"path": service}).Set(memory) //memory over time

	summary.With(prometheus.Labels{"path": service}).Observe(total)
	summaryMemory.With(prometheus.Labels{"path": service}).Observe(memory)
	summaryLocal.With(prometheus.Labels{"path": service}).Observe(local)

	histogram.With(prometheus.Labels{"path": service}).Observe(total)
	histogramMemory.With(prometheus.Labels{"path": service}).Observe(memory)
	histogramLocal.With(prometheus.Labels{"path": service}).Observe(local)

}

// databases
func db(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	sleep := time.Duration(randFloat(0, MaxSleep)*1000) * time.Millisecond
	time.Sleep(sleep)

	str := ""
	if r.URL.Query().Get("action") == "encode" {
		str = time.DateTime
	} else {
		str = base64.URLEncoding.EncodeToString([]byte(time.DateTime))
	}

	measure("db", sleep.Seconds(), time.Since(start).Seconds())

	_, err := w.Write([]byte(str))
	if err != nil {
		panic(err)
	}
}

// backends
func encode(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	sleep := time.Duration(randFloat(0, MaxSleep)*1000) * time.Millisecond
	time.Sleep(sleep)

	var str string
	err := requests.
		URL("http://" + GetEnv("DB_HOST", "localhost:8080") + "/db?action=encode").
		ToString(&str).
		Fetch(context.Background())
	if err != nil {
		panic(err)
	}

	measure("encode", sleep.Seconds(), time.Since(start).Seconds())

	_, err = w.Write([]byte(base64.StdEncoding.EncodeToString([]byte(str))))
	if err != nil {
		panic(err)
	}

}

func decode(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	sleep := time.Duration(randFloat(0, MaxSleep)*1000) * time.Millisecond
	time.Sleep(sleep)
	var s string
	err := requests.
		URL("http://" + GetEnv("DB_HOST", "localhost:8080") + "/db?action=decode").
		ToString(&s).
		Fetch(context.Background())
	if err != nil {
		panic(err)
	}

	measure("decode", sleep.Seconds(), time.Since(start).Seconds())
	data, _ := base64.StdEncoding.DecodeString(s)
	_, err = w.Write(data)
	if err != nil {
		panic(err)
	}
}

// frontend
func conceal(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	sleep := time.Duration(randFloat(0, MaxSleep)*1000) * time.Millisecond
	time.Sleep(sleep)

	var s string
	err := requests.
		URL("http://" + GetEnv("ENCODE_HOST", "localhost:8080") + "/encode").
		ToString(&s).
		Fetch(context.Background())
	if err != nil {
		panic(err)
	}

	measure("conceal", sleep.Seconds(), time.Since(start).Seconds())
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	res := AutoGenerated{s, time.Since(start).Seconds()}
	err = json.NewEncoder(w).Encode(res)
	if err != nil {
		panic(err)
	}
}

func show(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	sleep := time.Duration(randFloat(0, MaxSleep)*1000) * time.Millisecond
	time.Sleep(sleep)

	var s string
	err := requests.
		URL("http://" + GetEnv("DECODE_HOST", "localhost:8080") + "/decode").
		ToString(&s).
		Fetch(context.Background())
	if err != nil {
		panic(err)
	}

	measure("show", sleep.Seconds(), time.Since(start).Seconds())

	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	res := AutoGenerated{s, time.Since(start).Seconds()}
	err = json.NewEncoder(w).Encode(res)
	if err != nil {
		panic(err)
	}

}

func main() {

	reg := prometheus.NewRegistry()
	reg.MustRegister(counter)
	reg.MustRegister(histogram)
	reg.MustRegister(histogramMemory)
	reg.MustRegister(histogramLocal)
	reg.MustRegister(gauge)
	reg.MustRegister(summary)
	reg.MustRegister(summaryMemory)
	reg.MustRegister(summaryLocal)

	http.HandleFunc("/conceal", conceal)
	http.HandleFunc("/show", show)
	http.HandleFunc("/encode", encode)
	http.HandleFunc("/decode", decode)
	http.HandleFunc("/db", db)
	http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{Registry: reg}))
	log.Fatal(http.ListenAndServe(":8080", nil))
}
